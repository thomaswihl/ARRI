/**
* (C) COPYRIGHT 2020

CHANGED THAT LINE IN MYSBRANCH

*

ADDED A CONFLICTING LINE IN MASTER BRANCH

* @FILE ../SRC/APP/RPY_GENERATED/RINGBUFFER.H
* @AUTHOR MICHAELMAYER
* @BRIEF 
*
* RHAPSODY: 7.6
* COMPONENT: EMC
* CONFIGURATION: C166
* ELEMENT: RINGBUFFER
*
*/

#IFNDEF RINGBUFFER_H
#DEFINE RINGBUFFER_H

//#[ IGNORE
#IFDEF _MSC_VER
// DISABLE MICROSOFT COMPILER WARNING (DEBUG INFORMATION TRUNCATED)
#PRAGMA WARNING(DISABLE: 4786)
#ENDIF
//#]

#DEFINE A_NON_CONFLICTING_LINE

//## AUTO_GENERATED
#INCLUDE <OXF/OXF.H>
//## AUTO_GENERATED
#INCLUDE <STRING>
//## AUTO_GENERATED
#INCLUDE <ALGORITHM>
//## AUTO_GENERATED
#INCLUDE "TYPESPKG.H"
//## PACKAGE TYPESPKG

#INCLUDE "YETANOTHERMASTERFEATURE.H"
#INCLUDE "YETANOTHERBUGFIX.H"   // MYSBRANCH

//## CLASS RINGBUFFER
///
///IN OPPOSITION TO THE STL CONTAINERS THIS ONE DOESN'T STRETCH WITH THE AMOUNT OF DATA YOU PUT IN, BUT IT HAS A FIXED SIZE 
///AND IF YOU WRITE MORE THAN THAT INTO IT IT JUST OVERWRITES THE OLD DATA BEGINNING WITH THE FIRST ...
TEMPLATE <CLASS T> CLASS RINGBUFFER {
PUBLIC :

    //## AUTO_GENERATED
    CLASS ITERATOR;
    
    ///
    ///
    //## CLASS RINGBUFFER::ITERATOR
    CLASS ITERATOR {
        ////    CONSTRUCTORS AND DESTRUCTORS    ////
        
    PUBLIC :
    
        ///
        ///
        //## OPERATION ITERATOR(CONST ITERATOR&)
        ITERATOR(CONST ITERATOR& OTHER);
        
        ///
        ///
        //## OPERATION ITERATOR(UINT16_T,CONST RINGBUFFER<T>*)
        ITERATOR(UINT16_T INDEX, CONST RINGBUFFER<T>* RINGBUFFER);
        
        ////    OPERATIONS    ////
        
        ///
        ///
        //## OPERATION OPERATOR!=(CONST ITERATOR&) CONST
        INLINE BOOL OPERATOR!=(CONST ITERATOR& OTHER) CONST;
        
        ///
        ///
        //## OPERATION OPERATOR*() CONST
        INLINE T& OPERATOR*() CONST;
        
        ///
        ///
        //## OPERATION OPERATOR+(INT16_T) CONST
        INLINE TYPENAME RINGBUFFER<T>::ITERATOR OPERATOR+(INT16_T DISTANCE) CONST;
        
        ///
        ///
        //## OPERATION OPERATOR++()
        INLINE TYPENAME RINGBUFFER<T>::ITERATOR& OPERATOR++();
        
        ///
        ///
        //## OPERATION OPERATOR+=(INT16_T)
        TYPENAME RINGBUFFER<T>::ITERATOR& OPERATOR+=(INT16_T DISTANCE);
        
        ///
        ///
        //## OPERATION OPERATOR-(CONST ITERATOR&) CONST
        INLINE UINT16_T OPERATOR-(CONST ITERATOR& OTHER) CONST;
        
        ///
        ///
        //## OPERATION OPERATOR-(INT16_T) CONST
        INLINE TYPENAME RINGBUFFER<T>::ITERATOR OPERATOR-(INT16_T DISTANCE) CONST;
        
        ///
        ///
        //## OPERATION OPERATOR--()
        INLINE TYPENAME RINGBUFFER<T>::ITERATOR& OPERATOR--();
        
        ///
        ///
        //## OPERATION OPERATOR-=(INT16_T)
        INLINE TYPENAME RINGBUFFER<T>::ITERATOR& OPERATOR-=(INT16_T DISTANCE);
        
        ///
        ///
        //## OPERATION OPERATOR->() CONST
        INLINE CONST T* OPERATOR->() CONST;
        
        ///
        ///
        //## OPERATION OPERATOR=(CONST ITERATOR&)
        INLINE CONST TYPENAME RINGBUFFER<T>::ITERATOR& OPERATOR=(CONST ITERATOR& OTHER);
        
        ///
        ///
        //## OPERATION OPERATOR==(CONST ITERATOR&) CONST
        INLINE BOOL OPERATOR==(CONST ITERATOR& OTHER) CONST;
        
        ////    ATTRIBUTES    ////
    
    PRIVATE :
    
        ///
        ///
        UINT16_T INDEX;		//## ATTRIBUTE INDEX
        
        ///
        ///
        CONST RINGBUFFER<T>* ITSRINGBUFFER;		//## ATTRIBUTE ITSRINGBUFFER
    };
    
    ////    CONSTRUCTORS AND DESTRUCTORS    ////
    
    ///
    ///
    //## OPERATION RINGBUFFER(UINT16_T)
    RINGBUFFER(UINT16_T THECAPACITY);
    
    ///
    /// USE THIS CONSTRUCTOR WHEN YOU ALREADY HAVE A (LINEAR) BUFFER AND JUST WANT TO WRAPP A RINGBUFFER AROUND THAT.
    ///
    /// CAPACITY IS THE TOTAL SIZE OF THE GIVEN ARRAY.
    /// SIZE IS NUMBER OF ALREADY FILLED BYTES OF CONTENT.
    ///
    /// CAPACITY MUST BE BIGGER THAN SIZE!!
    //## OPERATION RINGBUFFER(T,UINT16_T,UINT16_T)
    RINGBUFFER(T* BUFFER, UINT16_T CAPACITY, UINT16_T SIZE);
    
    ///
    ///
    //## OPERATION ~RINGBUFFER()
    ~RINGBUFFER();
    
    ////    OPERATIONS    ////
    
    ///
    ///
    //## OPERATION BEGIN() CONST
    INLINE TYPENAME RINGBUFFER<T>::ITERATOR BEGIN() CONST;
    
    ///
    /// THIS RETURNS THE ACTUAL SIZE OF THE RESERVED SPACE. DUE TO THE INTERNAL HANDLING IT IS INDEED ONE MORE
    /// THAN THE CAPACITY ARGUMENT PROVIDED IN THE CONSTRUCTOR!
    //## OPERATION CAPACITY() CONST
    INLINE UINT16_T CAPACITY() CONST;
    
    ///
    ///
    //## OPERATION CLEAR()
    INLINE VOID CLEAR();
    
    ///
    ///
    //## OPERATION EMPTY() CONST
    INLINE BOOL EMPTY() CONST;
    
    ///
    ///
    //## OPERATION END() CONST
    INLINE TYPENAME RINGBUFFER<T>::ITERATOR END() CONST;
    
    ///
    /// HOW MANY ELEMENTS COULD BE STUFFED IN WITHOUT OVERRING ANY EXISTING.
    //## OPERATION FREE() CONST
    INLINE UINT16_T FREE() CONST;
    
    ///
    ///
    //## OPERATION FRONT()
    INLINE T& FRONT();
    
    ///
    ///
    //## OPERATION FULL() CONST
    INLINE BOOL FULL() CONST;
    
    ///
    /// JUST TAKE BACK THE PREVIOUSLY WRITTEN CHARACTER.
    ///
    /// PRECONDITION: !EMPTY()
    //## OPERATION POP_BACK()
    INLINE VOID POP_BACK();
    
    ///
    ///
    //## OPERATION POP_FRONT()
    INLINE VOID POP_FRONT();
    
    ///
    ///
    //## OPERATION PUSH_BACK(CONST T&)
    INLINE VOID PUSH_BACK(CONST T& ELEMENT);
    
    ///
    ///
    //## OPERATION SIZE() CONST
    INLINE UINT16_T SIZE() CONST;
    
    ////    ATTRIBUTES    ////

PRIVATE :

    ///
    ///
    CONST UINT16_T _CAPACITY;		//## ATTRIBUTE _CAPACITY
    
    ///
    ///
    UINT16_T _READ;		//## ATTRIBUTE _READ
    
    ///
    ///
    UINT16_T _WRITE;		//## ATTRIBUTE _WRITE
    
    ///
    /// REMEMBER IF WE SHOULD DELETE THE ELEMENTS IN DESTRUCTOR
    CONST BOOL DONTDELETE;		//## ATTRIBUTE DONTDELETE
    
    ///
    ///
    T* ELEMENTS;		//## ATTRIBUTE ELEMENTS
};

//## PACKAGE TYPESPKG

//## CLASS RINGBUFFER
TEMPLATE <CLASS T> RINGBUFFER<T>::RINGBUFFER(UINT16_T THECAPACITY) : _CAPACITY(THECAPACITY + 1), _READ(0), _WRITE(0), DONTDELETE(FALSE), ELEMENTS(NEW T[_CAPACITY]) {
    //#[ OPERATION RINGBUFFER(UINT16_T)
    //#]
}

TEMPLATE <CLASS T> RINGBUFFER<T>::RINGBUFFER(T* BUFFER, UINT16_T CAPACITY, UINT16_T SIZE) : _CAPACITY(CAPACITY), _READ(0), _WRITE(SIZE), DONTDELETE(TRUE), ELEMENTS(BUFFER) {
    //#[ OPERATION RINGBUFFER(T,UINT16_T,UINT16_T)
    //#]
}

TEMPLATE <CLASS T> RINGBUFFER<T>::~RINGBUFFER() {
    //#[ OPERATION ~RINGBUFFER()
    IF (!DONTDELETE) DELETE[] ELEMENTS;
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR RINGBUFFER<T>::BEGIN() CONST {
    //#[ OPERATION BEGIN() CONST
    ITERATOR ITER(_READ, THIS);
    RETURN ITER;
    //#]
}

TEMPLATE <CLASS T> INLINE UINT16_T RINGBUFFER<T>::CAPACITY() CONST {
    //#[ OPERATION CAPACITY() CONST
    RETURN _CAPACITY;
    //#]
}

TEMPLATE <CLASS T> INLINE VOID RINGBUFFER<T>::CLEAR() {
    //#[ OPERATION CLEAR()
    _READ = _WRITE;
    //#]
}

TEMPLATE <CLASS T> INLINE BOOL RINGBUFFER<T>::EMPTY() CONST {
    //#[ OPERATION EMPTY() CONST
    RETURN (_READ == _WRITE);
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR RINGBUFFER<T>::END() CONST {
    //#[ OPERATION END() CONST
    ITERATOR ITER(_WRITE, THIS);
    RETURN ITER;
    //#]
}

TEMPLATE <CLASS T> INLINE UINT16_T RINGBUFFER<T>::FREE() CONST {
    //#[ OPERATION FREE() CONST
    RETURN CAPACITY() - SIZE() - 1;
    //#]
}

TEMPLATE <CLASS T> INLINE T& RINGBUFFER<T>::FRONT() {
    //#[ OPERATION FRONT()
    RETURN ELEMENTS[_READ];
    //#]
}

TEMPLATE <CLASS T> INLINE BOOL RINGBUFFER<T>::FULL() CONST {
    //#[ OPERATION FULL() CONST
    UINT16_T IDX = _WRITE + 1;
    IF (IDX == _CAPACITY) IDX = 0;
    
    RETURN (IDX == _READ);
    //#]
}

TEMPLATE <CLASS T> INLINE VOID RINGBUFFER<T>::POP_BACK() {
    //#[ OPERATION POP_BACK()
    IF (_WRITE == _CAPACITY - 1) _WRITE = 0;
    ELSE --_WRITE;
    //#]
}

TEMPLATE <CLASS T> INLINE VOID RINGBUFFER<T>::POP_FRONT() {
    //#[ OPERATION POP_FRONT()
    UINT16_T IDX = _READ + 1;
    IF (IDX == _CAPACITY) IDX = 0;
    
    _READ = IDX;
    //#]
}

TEMPLATE <CLASS T> INLINE VOID RINGBUFFER<T>::PUSH_BACK(CONST T& ELEMENT) {
    //#[ OPERATION PUSH_BACK(CONST T&)
    UINT16_T IDX = _WRITE + 1;
    IF (IDX == _CAPACITY) IDX = 0;
    
    ELEMENTS[_WRITE] = ELEMENT;
    _WRITE = IDX;
    
    /* THIS IS DANGEROUS! WHEN A ISR EMPTIES US RIGHT IN THIS MOMENT
       WE SET THE BUFFER FROM EMPTY TO COMPLETE FULL!
    IF (_END == _BEGIN)
    {
        ++_BEGIN;   // WE JUST OVERWRITE, THE USER TAKES CARE OF THE CAPACITY!!
    }
    */
    //#]
}

TEMPLATE <CLASS T> INLINE UINT16_T RINGBUFFER<T>::SIZE() CONST {
    //#[ OPERATION SIZE() CONST
    UINT16_T SIZE = _WRITE - _READ;
    IF ((INT16_T)SIZE >= 0) RETURN SIZE;
    ELSE RETURN ((INT16_T)SIZE + _CAPACITY);
    //#]
}

TEMPLATE <CLASS T> RINGBUFFER<T>::ITERATOR::ITERATOR(CONST ITERATOR& OTHER) : ITSRINGBUFFER(OTHER.ITSRINGBUFFER), INDEX(OTHER.INDEX) {
    //#[ OPERATION ITERATOR(CONST ITERATOR&)
    //#]
}

TEMPLATE <CLASS T> RINGBUFFER<T>::ITERATOR::ITERATOR(UINT16_T INDEX, CONST RINGBUFFER<T>* RINGBUFFER) : ITSRINGBUFFER(RINGBUFFER), INDEX(INDEX) {
    //#[ OPERATION ITERATOR(UINT16_T,CONST RINGBUFFER<T>*)
    //#]
}

TEMPLATE <CLASS T> INLINE BOOL RINGBUFFER<T>::ITERATOR::OPERATOR!=(CONST ITERATOR& OTHER) CONST {
    //#[ OPERATION OPERATOR!=(CONST ITERATOR&) CONST
    RETURN (INDEX != OTHER.INDEX);
    //#]
}

TEMPLATE <CLASS T> INLINE T& RINGBUFFER<T>::ITERATOR::OPERATOR*() CONST {
    //#[ OPERATION OPERATOR*() CONST
    RETURN ITSRINGBUFFER->ELEMENTS[INDEX];
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR RINGBUFFER<T>::ITERATOR::OPERATOR+(INT16_T DISTANCE) CONST {
    //#[ OPERATION OPERATOR+(INT16_T) CONST
    ITERATOR ITER(*THIS);
    ITER += DISTANCE;
    RETURN ITER;
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR& RINGBUFFER<T>::ITERATOR::OPERATOR++() {
    //#[ OPERATION OPERATOR++()
    IF (INDEX == ITSRINGBUFFER->_CAPACITY - 1)  // WE ALREADY POINT TO LAST ELEMENT
    {
        INDEX = 0;
    }
    ELSE
    {
        ++INDEX;
    }
    RETURN *THIS;
    //#]
}

TEMPLATE <CLASS T> TYPENAME RINGBUFFER<T>::ITERATOR& RINGBUFFER<T>::ITERATOR::OPERATOR+=(INT16_T DISTANCE) {
    //#[ OPERATION OPERATOR+=(INT16_T)
    INT16_T NEWINDEX = INDEX + DISTANCE;
    
    IF (NEWINDEX >= ITSRINGBUFFER->_CAPACITY) 
    {
        NEWINDEX = NEWINDEX % ITSRINGBUFFER->_CAPACITY;
    }
    ELSE IF (NEWINDEX < 0)
    {
        NEWINDEX = -NEWINDEX;
        NEWINDEX = NEWINDEX % ITSRINGBUFFER->_CAPACITY;
        NEWINDEX = ITSRINGBUFFER->_CAPACITY - NEWINDEX;
    }
    
    INDEX = NEWINDEX;
    
    RETURN *THIS;
    //#]
}

TEMPLATE <CLASS T> INLINE UINT16_T RINGBUFFER<T>::ITERATOR::OPERATOR-(CONST ITERATOR& OTHER) CONST {
    //#[ OPERATION OPERATOR-(CONST ITERATOR&) CONST
    UINT16_T RESULT = INDEX - OTHER.INDEX;
    IF ((INT16_T)RESULT < 0) RESULT += ITSRINGBUFFER->_CAPACITY;
    RETURN RESULT;
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR RINGBUFFER<T>::ITERATOR::OPERATOR-(INT16_T DISTANCE) CONST {
    //#[ OPERATION OPERATOR-(INT16_T) CONST
    RETURN OPERATOR+(-DISTANCE);
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR& RINGBUFFER<T>::ITERATOR::OPERATOR--() {
    //#[ OPERATION OPERATOR--()
    IF (INDEX == 0)  // WE ALREADY POINT TO FIRST ELEMENT
    {
        INDEX = ITSRINGBUFFER->_CAPACITY - 1;
    }
    ELSE
    {
        --INDEX;
    }
    RETURN *THIS;
    //#]
}

TEMPLATE <CLASS T> INLINE TYPENAME RINGBUFFER<T>::ITERATOR& RINGBUFFER<T>::ITERATOR::OPERATOR-=(INT16_T DISTANCE) {
    //#[ OPERATION OPERATOR-=(INT16_T)
    RETURN OPERATOR+=(-DISTANCE);
    //#]
}

TEMPLATE <CLASS T> INLINE CONST T* RINGBUFFER<T>::ITERATOR::OPERATOR->() CONST {
    //#[ OPERATION OPERATOR->() CONST
    RETURN &ITSRINGBUFFER->ELEMENTS[INDEX];
    //#]
}

TEMPLATE <CLASS T> INLINE CONST TYPENAME RINGBUFFER<T>::ITERATOR& RINGBUFFER<T>::ITERATOR::OPERATOR=(CONST ITERATOR& OTHER) {
    //#[ OPERATION OPERATOR=(CONST ITERATOR&)
    INDEX = OTHER.INDEX;
    ITSRINGBUFFER = OTHER.ITSRINGBUFFER;
    RETURN *THIS;
    //#]
}

TEMPLATE <CLASS T> INLINE BOOL RINGBUFFER<T>::ITERATOR::OPERATOR==(CONST ITERATOR& OTHER) CONST {
    //#[ OPERATION OPERATOR==(CONST ITERATOR&) CONST
    RETURN (INDEX == OTHER.INDEX);
    //#]
}

#ENDIF
/*********************************************************************
	FILE PATH	: ../SRC/APP/RPY_GENERATED/RINGBUFFER.H
*********************************************************************/
